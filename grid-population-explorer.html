<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>5x5 Grid Population Explorer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #e5e5e5;
      min-height: 100vh;
    }

    .container {
      display: grid;
      grid-template-columns: 300px 1fr 280px;
      min-height: 100vh;
    }

    .panel {
      padding: 20px;
      border-right: 1px solid #222;
      overflow-y: auto;
    }

    .panel:last-child {
      border-right: none;
    }

    .panel-title {
      font-size: 11px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 16px;
    }

    /* Left Panel - Word Lists */
    .word-section {
      margin-bottom: 24px;
    }

    .word-section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .word-section-title {
      font-size: 12px;
      font-weight: 600;
      color: #888;
    }

    .word-count {
      font-size: 11px;
      color: #555;
      background: #1a1a1a;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .word-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .word-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: #151515;
      border-radius: 6px;
      border: 1px solid #222;
      cursor: pointer;
      transition: all 0.15s;
    }

    .word-item:hover {
      background: #1a1a1a;
      border-color: #333;
    }

    .word-item.placed {
      background: #1a2a1f;
      border-color: #2a4a3a;
    }

    .word-item.unplaced {
      background: #2a1a1a;
      border-color: #4a2a2a;
      opacity: 0.7;
    }

    .word-item.highlight {
      border-color: #5cb85c;
      box-shadow: 0 0 0 1px #5cb85c;
    }

    .word-text {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 1px;
    }

    .word-item.keyword .word-text { color: #6eb5ff; }
    .word-item.filler .word-text { color: #ffd666; }

    .word-meta {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .word-length {
      font-size: 10px;
      color: #666;
      background: #0a0a0a;
      padding: 2px 5px;
      border-radius: 3px;
    }

    .word-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .word-status.placed { background: #5cb85c; }
    .word-status.unplaced { background: #d9534f; }
    .word-status.pending { background: #555; }

    /* Center Panel - Grid */
    .center-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
      background: #0f0f0f;
    }

    .grid-container {
      margin-bottom: 24px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(5, 64px);
      grid-template-rows: repeat(5, 64px);
      gap: 3px;
      background: #222;
      padding: 3px;
      border-radius: 8px;
    }

    .cell {
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 24px;
      font-weight: 700;
      color: #fff;
      position: relative;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .cell.black {
      background: #000;
    }

    .cell.filled {
      background: #252525;
    }

    .cell.keyword-cell {
      background: linear-gradient(135deg, #1a2a3a, #1a2530);
      color: #6eb5ff;
    }

    .cell.filler-cell {
      background: linear-gradient(135deg, #2a2a1a, #252518);
      color: #ffd666;
    }

    .cell.intersection {
      box-shadow: inset 0 0 0 2px #5cb85c;
    }

    .cell-number {
      position: absolute;
      top: 3px;
      left: 4px;
      font-size: 9px;
      font-weight: 600;
      color: #888;
    }

    .cell.highlight-cell {
      animation: pulse 0.5s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    .btn {
      padding: 10px 20px;
      background: #252525;
      border: 1px solid #333;
      border-radius: 6px;
      color: #ccc;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn:hover {
      background: #333;
      border-color: #444;
    }

    .btn.primary {
      background: #2d4a3e;
      border-color: #3d6a5e;
      color: #8fc;
    }

    .btn.primary:hover {
      background: #3d5a4e;
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Stats */
    .stats-row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: #5cb85c;
    }

    .stat-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Algorithm Steps */
    .steps-panel {
      background: #111;
      border-radius: 8px;
      padding: 16px;
      max-width: 500px;
      width: 100%;
    }

    .steps-title {
      font-size: 11px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .step-log {
      max-height: 200px;
      overflow-y: auto;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      line-height: 1.6;
    }

    .step-entry {
      padding: 4px 0;
      border-bottom: 1px solid #1a1a1a;
    }

    .step-entry:last-child {
      border-bottom: none;
    }

    .step-success { color: #5cb85c; }
    .step-fail { color: #d9534f; }
    .step-info { color: #888; }
    .step-try { color: #6eb5ff; }
    .step-blacksquare { color: #d4a574; }

    /* Right Panel - Explanation */
    .explanation {
      padding: 20px;
      background: #0a0a0a;
    }

    .info-card {
      background: #151515;
      border-radius: 8px;
      padding: 14px;
      margin-bottom: 16px;
      border: 1px solid #222;
    }

    .info-card-title {
      font-size: 12px;
      font-weight: 600;
      color: #888;
      margin-bottom: 8px;
    }

    .info-card-content {
      font-size: 12px;
      line-height: 1.6;
      color: #aaa;
    }

    .legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: #888;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }

    .legend-color.keyword { background: linear-gradient(135deg, #1a2a3a, #1a2530); border: 1px solid #3a5a7a; }
    .legend-color.filler { background: linear-gradient(135deg, #2a2a1a, #252518); border: 1px solid #5a5a3a; }
    .legend-color.black { background: #000; border: 1px solid #333; }
    .legend-color.intersection { background: #252525; box-shadow: inset 0 0 0 2px #5cb85c; }

    .pattern-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 8px;
    }

    .pattern-btn {
      padding: 8px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .pattern-btn:hover {
      border-color: #555;
    }

    .pattern-btn.active {
      border-color: #5cb85c;
      background: #1a2a1f;
    }

    .mini-grid {
      display: grid;
      grid-template-columns: repeat(5, 6px);
      grid-template-rows: repeat(5, 6px);
      gap: 1px;
    }

    .mini-cell {
      background: #333;
      border-radius: 1px;
    }

    .mini-cell.black {
      background: #000;
    }

    .score-bar {
      margin-top: 12px;
    }

    .score-bar-track {
      height: 8px;
      background: #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
    }

    .score-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #d9534f, #f0ad4e, #5cb85c);
      border-radius: 4px;
      transition: width 0.3s;
    }

    .score-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      font-size: 10px;
      color: #555;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Left Panel: Word Lists -->
    <div class="panel">
      <div class="panel-title">Word Pool</div>

      <div class="word-section">
        <div class="word-section-header">
          <span class="word-section-title" style="color: #6eb5ff;">Keywords (Islamic)</span>
          <span class="word-count" id="keyword-count">0/0</span>
        </div>
        <div class="word-list" id="keyword-list"></div>
      </div>

      <div class="word-section">
        <div class="word-section-header">
          <span class="word-section-title" style="color: #ffd666;">Filler Words</span>
          <span class="word-count" id="filler-count">0/0</span>
        </div>
        <div class="word-list" id="filler-list"></div>
      </div>
    </div>

    <!-- Center Panel: Grid -->
    <div class="center-panel">
      <div class="controls">
        <button class="btn" onclick="resetGrid()">Reset</button>
        <button class="btn primary" onclick="stepOnce()">Step</button>
        <button class="btn primary" onclick="autoFill()">Auto Fill</button>
        <button class="btn" onclick="randomizeWords()">New Words</button>
      </div>

      <div class="grid-container">
        <div class="grid" id="grid"></div>
      </div>

      <div class="stats-row">
        <div class="stat">
          <div class="stat-value" id="words-placed">0</div>
          <div class="stat-label">Words Placed</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="intersections">0</div>
          <div class="stat-label">Intersections</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="fill-pct">0%</div>
          <div class="stat-label">Fill</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="islamic-pct">0%</div>
          <div class="stat-label">Islamic</div>
        </div>
      </div>

      <div class="steps-panel">
        <div class="steps-title">Algorithm Log</div>
        <div class="step-log" id="step-log"></div>
      </div>
    </div>

    <!-- Right Panel: Explanation -->
    <div class="panel explanation">
      <div class="panel-title">How It Works</div>

      <div class="info-card">
        <div class="info-card-title">Legend</div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color keyword"></div>
            <span>Keyword (Islamic term)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color filler"></div>
            <span>Filler word</span>
          </div>
          <div class="legend-item">
            <div class="legend-color intersection"></div>
            <span>Intersection cell</span>
          </div>
          <div class="legend-item">
            <div class="legend-color black"></div>
            <span>Black square</span>
          </div>
        </div>
      </div>

      <div class="info-card">
        <div class="info-card-title">Black Square Pattern</div>
        <div class="pattern-selector" id="pattern-selector"></div>
      </div>

      <div class="info-card">
        <div class="info-card-title">Algorithm Steps</div>
        <div class="info-card-content">
          <strong>1. Seed Placement</strong><br>
          Longest keyword goes in row 0 (ACROSS).<br><br>
          <strong>2. Intersection Search</strong><br>
          Find words that share letters with placed words.<br><br>
          <strong>3. Priority Scoring</strong><br>
          More intersections = higher priority.<br><br>
          <strong>4. Validation</strong><br>
          Check bounds, conflicts, adjacency rules.<br><br>
          <strong>5. Black Square Assist</strong><br>
          For shorter words (2-4 letters), add a black square to create a valid slot.<br><br>
          <strong>6. Filler Words</strong><br>
          Use fillers when keywords can't fit.
        </div>
      </div>

      <div class="info-card">
        <div class="info-card-title">Grid Score</div>
        <div class="score-bar">
          <div class="score-bar-track">
            <div class="score-bar-fill" id="score-fill" style="width: 0%"></div>
          </div>
          <div class="score-labels">
            <span>0</span>
            <span id="score-value">0</span>
            <span>100</span>
          </div>
        </div>
        <div class="info-card-content" style="margin-top: 12px; font-size: 11px;">
          Words: 40pts max | Intersections: 30pts | Fill: 20pts | Balance: 10pts
        </div>
      </div>
    </div>
  </div>

  <script>
    // Islamic keywords
    const ISLAMIC_KEYWORDS = [
      { word: 'QURAN', clue: 'Muslim holy book' },
      { word: 'MUSA', clue: 'Prophet Moses' },
      { word: 'ADAM', clue: 'First prophet' },
      { word: 'SALAT', clue: 'Daily prayers' },
      { word: 'HAJJ', clue: 'Pilgrimage' },
      { word: 'ZAKAT', clue: 'Charity pillar' },
      { word: 'IMAN', clue: 'Faith' },
      { word: 'JANNAH', clue: 'Paradise' },
      { word: 'ALLAH', clue: 'God in Arabic' },
      { word: 'ISLAM', clue: 'Submission to God' },
      { word: 'NUH', clue: 'Prophet Noah' },
      { word: 'ISA', clue: 'Prophet Jesus' },
      { word: 'MECCA', clue: 'Holiest city' },
      { word: 'SALAM', clue: 'Peace greeting' },
      { word: 'DUA', clue: 'Supplication' },
      { word: 'TAWBA', clue: 'Repentance' },
      { word: 'SABR', clue: 'Patience' },
      { word: 'HIDAYA', clue: 'Guidance' },
      { word: 'RAHMA', clue: 'Mercy' },
      { word: 'NUR', clue: 'Light' }
    ];

    // Filler words (common English with Islamic-adjacent clues)
    const FILLER_WORDS = [
      { word: 'PEACE', clue: 'Tranquility' },
      { word: 'LIGHT', clue: 'Illumination' },
      { word: 'TRUTH', clue: 'Reality' },
      { word: 'FAITH', clue: 'Belief' },
      { word: 'GRACE', clue: 'Divine favor' },
      { word: 'GUIDE', clue: 'One who leads' },
      { word: 'HEART', clue: 'Seat of emotion' },
      { word: 'PURE', clue: 'Clean, untainted' },
      { word: 'SOUL', clue: 'Spirit within' },
      { word: 'HOPE', clue: 'Optimistic feeling' },
      { word: 'GOOD', clue: 'Virtuous' },
      { word: 'KIND', clue: 'Gentle nature' },
      { word: 'WISE', clue: 'Having wisdom' },
      { word: 'JUST', clue: 'Fair, righteous' },
      { word: 'TRUE', clue: 'Accurate, honest' }
    ];

    // Black square patterns (point-symmetric)
    const PATTERNS = [
      [],                                    // No black squares
      [[0, 4], [4, 0]],                     // Two corners
      [[0, 4]],                             // Single corner
      [[2, 2]],                             // Center
      [[0, 4], [1, 4], [4, 0], [3, 0]],    // L-shapes
      [[0, 4], [4, 0], [4, 4], [0, 0]],    // Four corners
      [[2, 0], [2, 4]],                     // Side notches
      [[1, 2], [3, 2]]                      // Vertical center
    ];

    let state = {
      grid: [],
      blackSquares: new Set(),
      placedWords: [],
      usedWords: new Set(),
      currentPattern: 0,
      keywords: [],
      fillers: [],
      stepIndex: 0,
      wordQueue: [],
      logs: []
    };

    function initState() {
      // Create empty grid
      state.grid = Array(5).fill(null).map(() =>
        Array(5).fill(null).map(() => ({ letter: '', wordType: null, number: null, isIntersection: false }))
      );
      state.blackSquares = new Set();
      state.placedWords = [];
      state.usedWords = new Set();
      state.stepIndex = 0;
      state.logs = [];

      // Apply black square pattern
      const pattern = PATTERNS[state.currentPattern];
      pattern.forEach(([r, c]) => {
        state.blackSquares.add(`${r},${c}`);
        // Add symmetric position
        state.blackSquares.add(`${4-r},${4-c}`);
      });

      // Select random subset of keywords and fillers
      state.keywords = shuffle([...ISLAMIC_KEYWORDS])
        .filter(w => w.word.length <= 5)
        .slice(0, 8);
      state.fillers = shuffle([...FILLER_WORDS])
        .filter(w => w.word.length <= 5)
        .slice(0, 6);

      // Build word queue: keywords first (longest first), then fillers
      state.wordQueue = [
        ...state.keywords.map(k => ({ ...k, type: 'keyword' })),
        ...state.fillers.map(f => ({ ...f, type: 'filler' }))
      ].sort((a, b) => b.word.length - a.word.length);

      addLog('Initialized grid with pattern ' + state.currentPattern, 'info');
      addLog(`Keywords: ${state.keywords.map(k => k.word).join(', ')}`, 'info');
    }

    function shuffle(arr) {
      const result = [...arr];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    }

    function addLog(msg, type = 'info') {
      state.logs.push({ msg, type });
      renderLogs();
    }

    function renderLogs() {
      const log = document.getElementById('step-log');
      log.innerHTML = state.logs.slice(-20).map(l =>
        `<div class="step-entry step-${l.type}">${l.msg}</div>`
      ).join('');
      log.scrollTop = log.scrollHeight;
    }

    function canPlaceWord(word, row, col, dir) {
      const len = word.length;

      // Check bounds
      if (dir === 'across') {
        if (col + len > 5) return false;
      } else {
        if (row + len > 5) return false;
      }

      // Check each cell
      for (let i = 0; i < len; i++) {
        const r = dir === 'across' ? row : row + i;
        const c = dir === 'across' ? col + i : col;

        // Black square check
        if (state.blackSquares.has(`${r},${c}`)) return false;

        // Letter conflict check
        const cell = state.grid[r][c];
        if (cell.letter && cell.letter !== word[i]) return false;
      }

      // Check boundaries (no adjacent parallel words)
      if (dir === 'across') {
        // Check left boundary
        if (col > 0 && state.grid[row][col - 1].letter) return false;
        // Check right boundary
        if (col + len < 5 && state.grid[row][col + len].letter) return false;
      } else {
        // Check top boundary
        if (row > 0 && state.grid[row - 1][col].letter) return false;
        // Check bottom boundary
        if (row + len < 5 && state.grid[row + len][col].letter) return false;
      }

      return true;
    }

    function findIntersections(word) {
      const positions = [];

      for (let i = 0; i < word.length; i++) {
        const letter = word[i];

        // Find this letter in the grid
        for (let r = 0; r < 5; r++) {
          for (let c = 0; c < 5; c++) {
            if (state.grid[r][c].letter === letter) {
              // Try placing ACROSS (letter at position i means col = c - i)
              const acrossCol = c - i;
              if (acrossCol >= 0 && canPlaceWord(word, r, acrossCol, 'across')) {
                const intersections = countIntersections(word, r, acrossCol, 'across');
                if (intersections > 0) {
                  positions.push({ row: r, col: acrossCol, dir: 'across', intersections });
                }
              }

              // Try placing DOWN (letter at position i means row = r - i)
              const downRow = r - i;
              if (downRow >= 0 && canPlaceWord(word, downRow, c, 'down')) {
                const intersections = countIntersections(word, downRow, c, 'down');
                if (intersections > 0) {
                  positions.push({ row: downRow, col: c, dir: 'down', intersections });
                }
              }
            }
          }
        }
      }

      // Sort by intersection count (more = better)
      return positions.sort((a, b) => b.intersections - a.intersections);
    }

    function countIntersections(word, row, col, dir) {
      let count = 0;
      for (let i = 0; i < word.length; i++) {
        const r = dir === 'across' ? row : row + i;
        const c = dir === 'across' ? col + i : col;
        if (state.grid[r][c].letter === word[i]) count++;
      }
      return count;
    }

    /**
     * Find positions where a word could fit if we add a black square to bound it.
     * This is useful for shorter words that don't have natural intersections.
     * Also checks for positions adjacent to existing words (even without letter intersection).
     */
    function findPositionsWithBlackSquare(word) {
      const positions = [];
      const len = word.length;

      // Helper: check if a position is adjacent to any filled cell
      function isAdjacentToFilled(row, col, dir) {
        for (let i = 0; i < len; i++) {
          const r = dir === 'across' ? row : row + i;
          const c = dir === 'across' ? col + i : col;

          // Check all 4 adjacent cells
          const adjacent = [
            [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]
          ];

          for (const [ar, ac] of adjacent) {
            if (ar >= 0 && ar < 5 && ac >= 0 && ac < 5) {
              if (state.grid[ar][ac].letter && !state.blackSquares.has(`${ar},${ac}`)) {
                // Make sure it's not the same row/col we're placing in (would be intersection, not adjacent)
                if (dir === 'across' && ar !== row) return true;
                if (dir === 'down' && ac !== col) return true;
              }
            }
          }
        }
        return false;
      }

      // For each row, try placing ACROSS with a black square bounding
      for (let r = 0; r < 5; r++) {
        // Try all possible starting columns
        for (let startCol = 0; startCol <= 5 - len; startCol++) {
          // Case 1: Word needs black square AFTER (at endCol)
          const endCol = startCol + len;
          if (endCol < 5 && !state.blackSquares.has(`${r},${endCol}`) && !state.grid[r][endCol]?.letter) {
            // Check if left is bounded (edge or existing letter/black)
            const leftBounded = startCol === 0 ||
                               state.blackSquares.has(`${r},${startCol-1}`) ||
                               (state.grid[r][startCol-1]?.letter && !canShareLetter(word[0], r, startCol-1));

            if (leftBounded && canPlaceWordIgnoringBoundary(word, r, startCol, 'across')) {
              const intersections = countIntersections(word, r, startCol, 'across');
              const adjacent = isAdjacentToFilled(r, startCol, 'across');
              if (intersections > 0 || adjacent) {
                positions.push({
                  row: r, col: startCol, dir: 'across',
                  intersections: intersections > 0 ? intersections : 0.5,
                  needsBlackSquare: { row: r, col: endCol },
                  reason: `Add black at R${r+1}C${endCol+1} to bound right`
                });
              }
            }
          }

          // Case 2: Word needs black square BEFORE (at startCol - 1)
          const blackCol = startCol - 1;
          if (blackCol >= 0 && !state.blackSquares.has(`${r},${blackCol}`) && !state.grid[r][blackCol]?.letter) {
            // Check if right is bounded (edge or existing letter/black)
            const rightBounded = (startCol + len) === 5 ||
                                state.blackSquares.has(`${r},${startCol + len}`) ||
                                (state.grid[r][startCol + len]?.letter && !canShareLetter(word[len-1], r, startCol + len));

            if (rightBounded && canPlaceWordIgnoringBoundary(word, r, startCol, 'across')) {
              const intersections = countIntersections(word, r, startCol, 'across');
              const adjacent = isAdjacentToFilled(r, startCol, 'across');
              if (intersections > 0 || adjacent) {
                positions.push({
                  row: r, col: startCol, dir: 'across',
                  intersections: intersections > 0 ? intersections : 0.5,
                  needsBlackSquare: { row: r, col: blackCol },
                  reason: `Add black at R${r+1}C${blackCol+1} to bound left`
                });
              }
            }
          }
        }
      }

      // For each column, try placing DOWN with a black square bounding
      for (let c = 0; c < 5; c++) {
        // Try all possible starting rows
        for (let startRow = 0; startRow <= 5 - len; startRow++) {
          // Case 1: Word needs black square AFTER (at endRow)
          const endRow = startRow + len;
          if (endRow < 5 && !state.blackSquares.has(`${endRow},${c}`) && !state.grid[endRow]?.[c]?.letter) {
            // Check if top is bounded (edge or existing letter/black)
            const topBounded = startRow === 0 ||
                              state.blackSquares.has(`${startRow-1},${c}`) ||
                              (state.grid[startRow-1]?.[c]?.letter && !canShareLetter(word[0], startRow-1, c));

            if (topBounded && canPlaceWordIgnoringBoundary(word, startRow, c, 'down')) {
              const intersections = countIntersections(word, startRow, c, 'down');
              const adjacent = isAdjacentToFilled(startRow, c, 'down');
              if (intersections > 0 || adjacent) {
                positions.push({
                  row: startRow, col: c, dir: 'down',
                  intersections: intersections > 0 ? intersections : 0.5,
                  needsBlackSquare: { row: endRow, col: c },
                  reason: `Add black at R${endRow+1}C${c+1} to bound below`
                });
              }
            }
          }

          // Case 2: Word needs black square BEFORE (at startRow - 1)
          const blackRow = startRow - 1;
          if (blackRow >= 0 && !state.blackSquares.has(`${blackRow},${c}`) && !state.grid[blackRow]?.[c]?.letter) {
            // Check if bottom is bounded (edge or existing letter/black)
            const bottomBounded = (startRow + len) === 5 ||
                                 state.blackSquares.has(`${startRow + len},${c}`) ||
                                 (state.grid[startRow + len]?.[c]?.letter && !canShareLetter(word[len-1], startRow + len, c));

            if (bottomBounded && canPlaceWordIgnoringBoundary(word, startRow, c, 'down')) {
              const intersections = countIntersections(word, startRow, c, 'down');
              const adjacent = isAdjacentToFilled(startRow, c, 'down');
              if (intersections > 0 || adjacent) {
                positions.push({
                  row: startRow, col: c, dir: 'down',
                  intersections: intersections > 0 ? intersections : 0.5,
                  needsBlackSquare: { row: blackRow, col: c },
                  reason: `Add black at R${blackRow+1}C${c+1} to bound above`
                });
              }
            }
          }
        }
      }

      // Deduplicate positions (same row, col, dir)
      const seen = new Set();
      const uniquePositions = positions.filter(p => {
        const key = `${p.row},${p.col},${p.dir}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });

      return uniquePositions.sort((a, b) => b.intersections - a.intersections);
    }

    // Helper: check if a letter could share a cell (same letter)
    function canShareLetter(letter, row, col) {
      return state.grid[row]?.[col]?.letter === letter;
    }

    // Helper: check if adding a black square would break any existing word
    function wouldBreakExistingWord(blackRow, blackCol) {
      // Check if this cell is part of any placed word
      for (const word of state.placedWords) {
        for (let i = 0; i < word.word.length; i++) {
          const r = word.dir === 'across' ? word.row : word.row + i;
          const c = word.dir === 'across' ? word.col + i : word.col;
          if (r === blackRow && c === blackCol) {
            return true; // Would cut through an existing word
          }
        }
        // Also check symmetric position
        const symRow = 4 - blackRow;
        const symCol = 4 - blackCol;
        for (let i = 0; i < word.word.length; i++) {
          const r = word.dir === 'across' ? word.row : word.row + i;
          const c = word.dir === 'across' ? word.col + i : word.col;
          if (r === symRow && c === symCol) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * Check if a word can be placed, ignoring boundary checks (for black square assisted placement)
     */
    function canPlaceWordIgnoringBoundary(word, row, col, dir) {
      const len = word.length;

      // Check bounds
      if (dir === 'across') {
        if (col + len > 5) return false;
      } else {
        if (row + len > 5) return false;
      }

      // Check each cell
      for (let i = 0; i < len; i++) {
        const r = dir === 'across' ? row : row + i;
        const c = dir === 'across' ? col + i : col;

        // Black square check
        if (state.blackSquares.has(`${r},${c}`)) return false;

        // Letter conflict check
        const cell = state.grid[r][c];
        if (cell.letter && cell.letter !== word[i]) return false;
      }

      return true;
    }

    /**
     * Add a black square and its symmetric counterpart
     */
    function addBlackSquare(row, col) {
      state.blackSquares.add(`${row},${col}`);
      // Add symmetric position for point-symmetric grid
      state.blackSquares.add(`${4-row},${4-col}`);
      state.grid[row][col] = { letter: '', wordType: null, number: null, isIntersection: false };
      state.grid[4-row][4-col] = { letter: '', wordType: null, number: null, isIntersection: false };
    }

    function placeWord(wordObj, row, col, dir) {
      const word = wordObj.word;
      const clueNum = state.placedWords.length + 1;

      for (let i = 0; i < word.length; i++) {
        const r = dir === 'across' ? row : row + i;
        const c = dir === 'across' ? col + i : col;
        const cell = state.grid[r][c];

        if (cell.letter && cell.letter === word[i]) {
          cell.isIntersection = true;
        }

        cell.letter = word[i];
        if (!cell.wordType) {
          cell.wordType = wordObj.type;
        }
        if (i === 0) {
          cell.number = clueNum;
        }
      }

      state.placedWords.push({
        ...wordObj,
        row, col, dir,
        number: clueNum
      });
      state.usedWords.add(wordObj.word);
    }

    function stepOnce() {
      // Find next word to place
      const remaining = state.wordQueue.filter(w => !state.usedWords.has(w.word));

      if (remaining.length === 0) {
        addLog('No more words to place!', 'info');
        return false;
      }

      // First word: place as seed in row 0
      if (state.placedWords.length === 0) {
        const seed = remaining[0];
        if (seed.word.length <= 5 && canPlaceWord(seed.word, 0, 0, 'across')) {
          placeWord(seed, 0, 0, 'across');
          addLog(`SEED: Placed "${seed.word}" at (0,0) ACROSS`, 'success');
          renderAll();
          return true;
        } else {
          addLog(`Failed to place seed "${seed.word}"`, 'fail');
          state.usedWords.add(seed.word);
          return stepOnce();
        }
      }

      // Try to find a word that intersects
      for (const wordObj of remaining) {
        addLog(`Trying "${wordObj.word}" (${wordObj.type})...`, 'try');

        const positions = findIntersections(wordObj.word);

        if (positions.length > 0) {
          const best = positions[0];
          placeWord(wordObj, best.row, best.col, best.dir);
          addLog(`PLACED: "${wordObj.word}" at (${best.row},${best.col}) ${best.dir.toUpperCase()} (${best.intersections} intersections)`, 'success');
          renderAll();
          return true;
        } else {
          // Try black square assisted placement for shorter words
          if (wordObj.word.length < 5) {
            const blackSquarePositions = findPositionsWithBlackSquare(wordObj.word);
            // Find a position that doesn't break existing words
            for (const pos of blackSquarePositions) {
              if (!wouldBreakExistingWord(pos.needsBlackSquare.row, pos.needsBlackSquare.col)) {
                // Add the black square first
                addBlackSquare(pos.needsBlackSquare.row, pos.needsBlackSquare.col);
                addLog(`⬛ Added black at R${pos.needsBlackSquare.row+1}C${pos.needsBlackSquare.col+1} (+ symmetric R${5-pos.needsBlackSquare.row}C${5-pos.needsBlackSquare.col})`, 'blacksquare');
                // Now place the word
                placeWord(wordObj, pos.row, pos.col, pos.dir);
                addLog(`PLACED (□ assist): "${wordObj.word}" at R${pos.row+1}C${pos.col+1} ${pos.dir.toUpperCase()}`, 'success');
                renderAll();
                return true;
              }
            }
          }
          addLog(`No valid position for "${wordObj.word}"`, 'fail');
        }
      }

      addLog('No more words can be placed', 'info');
      renderAll();
      return false;
    }

    function autoFill() {
      const interval = setInterval(() => {
        if (!stepOnce()) {
          clearInterval(interval);
        }
      }, 400);
    }

    function calculateScore() {
      const wordCount = state.placedWords.length;
      const acrossCount = state.placedWords.filter(w => w.dir === 'across').length;
      const downCount = state.placedWords.filter(w => w.dir === 'down').length;

      let filledCells = 0;
      let intersections = 0;

      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          if (state.grid[r][c].letter) filledCells++;
          if (state.grid[r][c].isIntersection) intersections++;
        }
      }

      // Score calculation
      let score = 0;
      score += Math.min(wordCount * 6, 40);  // Words: max 40
      score += Math.min(intersections * 5, 30);  // Intersections: max 30
      score += Math.floor((filledCells / 25) * 20);  // Fill: max 20

      if (acrossCount > 0 && downCount > 0) {
        const balance = Math.min(acrossCount, downCount) / Math.max(acrossCount, downCount);
        score += Math.floor(balance * 10);  // Balance: max 10
      }

      return { score, wordCount, intersections, filledCells };
    }

    function renderGrid() {
      const gridEl = document.getElementById('grid');
      gridEl.innerHTML = '';

      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 5; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          if (state.blackSquares.has(`${r},${c}`)) {
            cell.classList.add('black');
          } else if (state.grid[r][c].letter) {
            cell.classList.add('filled');
            if (state.grid[r][c].wordType === 'keyword') {
              cell.classList.add('keyword-cell');
            } else if (state.grid[r][c].wordType === 'filler') {
              cell.classList.add('filler-cell');
            }
            if (state.grid[r][c].isIntersection) {
              cell.classList.add('intersection');
            }
            cell.textContent = state.grid[r][c].letter;

            if (state.grid[r][c].number) {
              const numEl = document.createElement('span');
              numEl.className = 'cell-number';
              numEl.textContent = state.grid[r][c].number;
              cell.appendChild(numEl);
            }
          }

          gridEl.appendChild(cell);
        }
      }
    }

    function renderWordLists() {
      const keywordList = document.getElementById('keyword-list');
      const fillerList = document.getElementById('filler-list');

      const placedKeywords = state.placedWords.filter(w => w.type === 'keyword').length;
      const placedFillers = state.placedWords.filter(w => w.type === 'filler').length;

      document.getElementById('keyword-count').textContent = `${placedKeywords}/${state.keywords.length}`;
      document.getElementById('filler-count').textContent = `${placedFillers}/${state.fillers.length}`;

      keywordList.innerHTML = state.keywords.map(k => {
        const isPlaced = state.usedWords.has(k.word);
        const placedData = state.placedWords.find(p => p.word === k.word);
        return `
          <div class="word-item keyword ${isPlaced ? 'placed' : ''}">
            <span class="word-text">${k.word}</span>
            <div class="word-meta">
              ${placedData ? `<span class="word-length">${placedData.dir === 'across' ? '→' : '↓'}</span>` : ''}
              <span class="word-length">${k.word.length}</span>
              <span class="word-status ${isPlaced ? 'placed' : 'pending'}"></span>
            </div>
          </div>
        `;
      }).join('');

      fillerList.innerHTML = state.fillers.map(f => {
        const isPlaced = state.usedWords.has(f.word);
        const placedData = state.placedWords.find(p => p.word === f.word);
        return `
          <div class="word-item filler ${isPlaced ? 'placed' : ''}">
            <span class="word-text">${f.word}</span>
            <div class="word-meta">
              ${placedData ? `<span class="word-length">${placedData.dir === 'across' ? '→' : '↓'}</span>` : ''}
              <span class="word-length">${f.word.length}</span>
              <span class="word-status ${isPlaced ? 'placed' : 'pending'}"></span>
            </div>
          </div>
        `;
      }).join('');
    }

    function renderStats() {
      const stats = calculateScore();

      document.getElementById('words-placed').textContent = stats.wordCount;
      document.getElementById('intersections').textContent = stats.intersections;
      document.getElementById('fill-pct').textContent = Math.round((stats.filledCells / 25) * 100) + '%';

      const islamicPlaced = state.placedWords.filter(w => w.type === 'keyword').length;
      const islamicPct = stats.wordCount > 0 ? Math.round((islamicPlaced / stats.wordCount) * 100) : 0;
      const islamicEl = document.getElementById('islamic-pct');
      islamicEl.textContent = islamicPct + '%';
      islamicEl.style.color = islamicPct >= 50 ? '#5cb85c' : '#d9534f';

      document.getElementById('score-fill').style.width = stats.score + '%';
      document.getElementById('score-value').textContent = stats.score;
    }

    function renderPatternSelector() {
      const selector = document.getElementById('pattern-selector');
      selector.innerHTML = PATTERNS.map((pattern, idx) => {
        const blackSet = new Set();
        pattern.forEach(([r, c]) => {
          blackSet.add(`${r},${c}`);
          blackSet.add(`${4-r},${4-c}`);
        });

        let miniGrid = '<div class="mini-grid">';
        for (let r = 0; r < 5; r++) {
          for (let c = 0; c < 5; c++) {
            miniGrid += `<div class="mini-cell ${blackSet.has(`${r},${c}`) ? 'black' : ''}"></div>`;
          }
        }
        miniGrid += '</div>';

        return `<div class="pattern-btn ${idx === state.currentPattern ? 'active' : ''}" onclick="selectPattern(${idx})">${miniGrid}</div>`;
      }).join('');
    }

    function selectPattern(idx) {
      state.currentPattern = idx;
      resetGrid();
    }

    function renderAll() {
      renderGrid();
      renderWordLists();
      renderStats();
      renderPatternSelector();
    }

    function resetGrid() {
      initState();
      renderAll();
    }

    function randomizeWords() {
      state.currentPattern = Math.floor(Math.random() * PATTERNS.length);
      resetGrid();
    }

    // Initialize
    resetGrid();
  </script>
</body>
</html>
